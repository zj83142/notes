## js 变量、作用域 和 内存问题

> javascript 的变量与其他语言的变量有很大区别。**javascript变量松散类型的本质，决定了它只能是在特定时间用于保存特定值的一个名字**，变量的值机器数据类型可以在脚本的生命周期内改变。

### 基本类型和引用类型的值

- 基本类型，指的是简单的数据段，基本类型值在内存中占用固定大小的控件，因此被保存在栈内存中。
- 引用类型，指那些可能有多个值构成的对象，引用类型的值是对象，保存在对内存中。

> **在讲一个值赋给变量时，解析器必须确定这个值是基本类型还是引用类型。**
> 引用类型的值是保存在内存对象中，与其他语言不同，javascript不与许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。

- 动态属性，只能给应用类型动态的添加属性，我们不能给基本类型的值添加属性，尽管它不会报错
- 复制变量值
  - 基本类型变量，会在变量对象上新建一个值用于复制，两个变量可以参与任何操作而不会相互影响
  - 引用类型变量，副本实际上是一个指针，复制操作完成后，两个变量实际上引用的同一个对象，改变其中一个变量，会影响另一个变量。
- 传递参数，参数只能是按值传递。**需要注意的是如果参数是基本类型，则参数是复制了一份，但是如果参数是应用类型，复制的还是指针。**
- 检测类型
  - typeof 操作符， 检测变量基本数据类型（字符串、数值、布尔值、undefined）
  - instanceof 操作符，检测对象或null

### 执行环境及作用域

#### 执行环境（execution content）
执行环境是javascript中最重要的一个概念之一。执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之相关联的变量对象（ariable Object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写代码无法访问这个对象，但是解析器在处理数据时会在后台使用它。

> - 在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。
  - 某个执行环境中的所有代码执行完毕后，该环境被销毁。保存在其中的所有变量和函数也随之被销毁。

每个函数都有自己的执行环境，当执行流进入一个函数时。函数的环境就会被推入到一个环境栈中，而在函数执行完毕后，栈将其环境弹出。把控制权返回给之前的执行环境。

#### 作用域链（scope chain）
当代码在环境中执行时，会创建变量对象的一个作用域链。作用域连的用途是：保证对执行环境中有权访问的变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在的环境的变量对象。

如果这个环境是函数，则其活动对象（activation Object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的），全局执行环境的变量对象始终都是作用域链中的最后一个对象。

标识符解析是沿着作用域链一级一级的搜索，搜索过程始终充作用域连的前端开始，然后主机向后回溯，直到找到标识符为止。
```
var color = 'blue';
function changeColor() {
  if(color === 'blue') {
    color = 'red';
  } else {
    color = 'blue';
  }
}
changeColor();
alert('color is now ' + color);
```
在这个简单的例子中，函数changeColor() 的作用域链包含两个对象： 他自身的变量对象（其中定义着arguments对象） 和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。

> 在执行环境中，可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性，有次序的，每个环境都可以向上搜索作用域链，以查询变量和函数名，但是任何环境都不能向下搜索作用域链而进入到另一个执行环境。

#### 延长作用域链

虽然执行环境的类型总共只有两种——全局和局部（函数），但是还是有办法来延长作用域链，这么说是因为有些语句可以在作用域链的前端临时添加一个变量对象。改变两度向会在代码执行后被移除。

- try-catch 语句 的catch块
- with语句(不推荐使用with关键字，原因：1、性能问题 2、语义不明，调试困难)

```
function buildUrl() {
  var qs = '?debug=true';
  with(location) {
    var url = href + qs;
  }
  return url;
}
```

### 垃圾收集

javascript 具有自动垃圾回收机制，执行环境会负责管理代码执行过程中使用的内存。

- 标记清除 最常用的垃圾收集方式。
- 引用计数 跟踪记录每个值被引用的次数。当垃圾收集器再次运行时，就会释放哪些引用次数为0的值所占用的内存. Netscape 在Navigator 4.0 中放弃了引用技术方式。

- 离开作用域的值将被自动标记为可回收。因此将在垃圾收集期间被删除。
- “标记清除”是目前最主流的垃圾收集算法，这种算法的思想是给当前不使用的值添加标记。然后在回收其内存。
- 解除变量引用（赋值为null）不仅有助于消除循环引用显现个，而且对垃圾收集也有好处。
